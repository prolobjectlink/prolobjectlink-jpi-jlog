<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JLogConverter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">prolobjectlink-jpi-jlog</a> &gt; <a href="index.source.html" class="el_package">io.github.prolobjectlink.prolog.jlog</a> &gt; <span class="el_source">JLogConverter.java</span></div><h1>JLogConverter.java</h1><pre class="source lang-java linenums">/*
 * #%L
 * prolobjectlink-jpi-jlog
 * %%
 * Copyright (C) 2019 Prolobjectlink Project
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with this program.  If not, see
 * &lt;http://www.gnu.org/licenses/gpl-3.0.html&gt;.
 * #L%
 */
package io.github.prolobjectlink.prolog.jlog;

import static io.github.prolobjectlink.prolog.PrologTermType.ATOM_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.CUT_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.DOUBLE_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.FAIL_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.FALSE_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.FLOAT_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.INTEGER_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.LIST_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.LONG_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.NIL_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.STRUCTURE_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.TRUE_TYPE;
import static io.github.prolobjectlink.prolog.PrologTermType.VARIABLE_TYPE;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;

import io.github.prolobjectlink.prolog.AbstractConverter;
import io.github.prolobjectlink.prolog.PrologAtom;
import io.github.prolobjectlink.prolog.PrologConverter;
import io.github.prolobjectlink.prolog.PrologDouble;
import io.github.prolobjectlink.prolog.PrologFloat;
import io.github.prolobjectlink.prolog.PrologInteger;
import io.github.prolobjectlink.prolog.PrologList;
import io.github.prolobjectlink.prolog.PrologLogger;
import io.github.prolobjectlink.prolog.PrologLong;
import io.github.prolobjectlink.prolog.PrologProvider;
import io.github.prolobjectlink.prolog.PrologStructure;
import io.github.prolobjectlink.prolog.PrologTerm;
import io.github.prolobjectlink.prolog.PrologVariable;
import io.github.prolobjectlink.prolog.UnknownTermError;
import ubc.cs.JLog.Foundation.jEquivalenceMapping;
import ubc.cs.JLog.Terms.jAtom;
import ubc.cs.JLog.Terms.jBinaryBuiltinPredicate;
import ubc.cs.JLog.Terms.jBuiltinPredicate;
import ubc.cs.JLog.Terms.jCompoundTerm;
import ubc.cs.JLog.Terms.jFail;
import ubc.cs.JLog.Terms.jInteger;
import ubc.cs.JLog.Terms.jList;
import ubc.cs.JLog.Terms.jListPair;
import ubc.cs.JLog.Terms.jNullList;
import ubc.cs.JLog.Terms.jPredicate;
import ubc.cs.JLog.Terms.jPredicateTerms;
import ubc.cs.JLog.Terms.jReal;
import ubc.cs.JLog.Terms.jTerm;
import ubc.cs.JLog.Terms.jTrue;
import ubc.cs.JLog.Terms.jUnaryBuiltinPredicate;
import ubc.cs.JLog.Terms.jVariable;

/**
 * 
 * @author Jose Zalacain
 * @since 1.0
 */
<span class="nc" id="L79">class JLogConverter extends AbstractConverter&lt;jTerm&gt; implements PrologConverter&lt;jTerm&gt; {</span>

<span class="nc" id="L81">	private final jPredicateTerms emptyBody = new jPredicateTerms();</span>
<span class="nc" id="L82">	private final jEquivalenceMapping equivalence = new jEquivalenceMapping();</span>

	private jList adaptList(PrologTerm[] arguments) {
<span class="nc" id="L85">		jList pList = jNullList.NULL_LIST;</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">		for (int i = arguments.length - 1; i &gt;= 0; --i) {</span>
<span class="nc" id="L87">			pList = new jListPair(fromTerm(arguments[i]), pList);</span>
		}
<span class="nc" id="L89">		return pList;</span>
	}

	private jCompoundTerm adaptCompound(PrologTerm[] arguments) {
<span class="nc" id="L93">		jCompoundTerm compound = new jCompoundTerm(arguments.length);</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">		for (PrologTerm iPrologTerm : arguments) {</span>
<span class="nc" id="L95">			compound.addTerm(fromTerm(iPrologTerm));</span>
		}
<span class="nc" id="L97">		return compound;</span>
	}

	public PrologTerm toTerm(jTerm prologTerm) {
<span class="nc bnc" id="L101" title="All 13 branches missed.">		switch (prologTerm.type) {</span>
		case jTerm.TYPE_NULLLIST:
<span class="nc" id="L103">			return new JLogEmpty(provider);</span>
		case jTerm.TYPE_ATOM:
<span class="nc" id="L105">			String value = prologTerm.getName();</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">			if (value.equals(JLogNil.NIL_STR)) {</span>
<span class="nc" id="L107">				return new JLogNil(provider);</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">			} else if (value.equals(JLogFalse.FALSE_STR)) {</span>
<span class="nc" id="L109">				return new JLogFalse(provider);</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">			} else if (!value.matches(SIMPLE_ATOM_REGEX)) {</span>
<span class="nc" id="L111">				return new JLogAtom(provider, &quot;'&quot; + value + &quot;'&quot;);</span>
			}
<span class="nc" id="L113">			return new JLogAtom(provider, value);</span>
		case jTerm.TYPE_INTEGER:
<span class="nc" id="L115">			return new JLogInteger(provider, ((jInteger) prologTerm).getIntegerValue());</span>
		case jTerm.TYPE_REAL:
<span class="nc" id="L117">			JLogTerm number = null;</span>
			try {
<span class="nc bnc" id="L119" title="All 2 branches missed.">				if (prologTerm instanceof jFloat) {</span>
<span class="nc" id="L120">					number = new JLogFloat(provider, ((jFloat) prologTerm).getRealValue());</span>
<span class="nc" id="L121">				} else {</span>
<span class="nc" id="L122">					number = new JLogDouble(provider, ((jDouble) prologTerm).getRealValue());</span>
				}
<span class="nc" id="L124">			} catch (ClassCastException e) {</span>
				// the parsed number is a jReal number we need convert in double or float
<span class="nc bnc" id="L126" title="All 2 branches missed.">				if (e.getMessage().contains(jFloat.class.getName())) {</span>
<span class="nc" id="L127">					number = new JLogFloat(provider, ((jReal) prologTerm).getRealValue());</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">				} else if (e.getMessage().contains(jDouble.class.getName())) {</span>
<span class="nc" id="L129">					number = new JLogDouble(provider, ((jReal) prologTerm).getRealValue());</span>
<span class="nc" id="L130">				} else {</span>
<span class="nc" id="L131">					getLogger().error(getClass(), PrologLogger.CLASS_CAST, e);</span>
				}
			}
<span class="nc" id="L134">			return number;</span>
		case jTerm.TYPE_VARIABLE:
<span class="nc" id="L136">			String name = ((jVariable) prologTerm).getName();</span>
<span class="nc" id="L137">			PrologVariable variable = sharedVariables.get(name);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">			if (variable == null) {</span>
<span class="nc" id="L139">				variable = new JLogVariable(provider, name);</span>
<span class="nc" id="L140">				sharedVariables.put(variable.getName(), variable);</span>
			}
<span class="nc" id="L142">			return variable;</span>
		case jTerm.TYPE_LIST:
<span class="nc" id="L144">			jTerm[] array = new jTerm[0];</span>
<span class="nc" id="L145">			jList list = (jList) prologTerm;</span>
<span class="nc" id="L146">			ArrayList&lt;jTerm&gt; arguments = new ArrayList&lt;jTerm&gt;();</span>
<span class="nc" id="L147">			Iterator&lt;jTerm&gt; i = new JLogIterator(list);</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">			while (i.hasNext()) {</span>
<span class="nc" id="L149">				arguments.add(i.next());</span>
			}
<span class="nc" id="L151">			return new JLogList(provider, arguments.toArray(array));</span>
		case jTerm.TYPE_OBJECT:
<span class="nc" id="L153">			return new JLogReference(provider, prologTerm);</span>
		case jTerm.TYPE_TYPE:
<span class="nc" id="L155">			jUnaryBuiltinPredicate unary=(jUnaryBuiltinPredicate) prologTerm;</span>
<span class="nc" id="L156">			return new JLogStructure(provider, unary.getName(), unary.getRHS());</span>
		case jTerm.TYPE_COMPARE:
		case jTerm.TYPE_OPERATOR:
		case jTerm.TYPE_ARITHMETIC:
		case jTerm.TYPE_UNARYOPERATOR:
		case jTerm.TYPE_NUMERICCOMPARE:
		case jTerm.TYPE_UNARYARITHMETIC:
<span class="nc" id="L163">			jBinaryBuiltinPredicate binary = (jBinaryBuiltinPredicate) prologTerm;</span>
<span class="nc" id="L164">			return new JLogStructure(provider, binary.getLHS(), binary.getName(), binary.getRHS());</span>
		case jTerm.TYPE_BUILTINPREDICATE:
<span class="nc" id="L166">			jBuiltinPredicate builtIn = (jBuiltinPredicate) prologTerm;</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">			if (builtIn.equivalence(jTrue.TRUE, equivalence)) {</span>
<span class="nc" id="L168">				return new JLogTrue(provider);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">			} else if (builtIn.equivalence(jFail.FAIL, equivalence)) {</span>
<span class="nc" id="L170">				return new JLogFail(provider);</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">			} else if (builtIn.equivalence(JLogCut.JCUT, equivalence)) {</span>
<span class="nc" id="L172">				return new JLogCut(provider);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">			} else if (builtIn.getArity() == 2) {</span>
<span class="nc" id="L174">				jBinaryBuiltinPredicate b = (jBinaryBuiltinPredicate) prologTerm;</span>
<span class="nc" id="L175">				return new JLogStructure(provider, b.getLHS(), b.getName(), b.getRHS());</span>
			}
<span class="nc" id="L177">			throw new UnknownTermError(prologTerm);</span>
		case jTerm.TYPE_PREDICATE:
<span class="nc" id="L179">			jPredicate predicate = (jPredicate) prologTerm;</span>
<span class="nc" id="L180">			jCompoundTerm compound = predicate.getArguments();</span>
<span class="nc" id="L181">			String functor = predicate.getName();</span>
<span class="nc" id="L182">			return new JLogStructure(provider, functor, compound);</span>
		case jTerm.TYPE_PREDICATETERMS:
<span class="nc" id="L184">			jPredicateTerms terms = (jPredicateTerms) prologTerm;</span>
<span class="nc" id="L185">			Enumeration&lt;?&gt; k = terms.enumTerms();</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">			if (k.hasMoreElements()) {</span>
<span class="nc" id="L187">				PrologTerm body = null;</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">				while (k.hasMoreElements()) {</span>
<span class="nc" id="L189">					jTerm term = (jTerm) k.nextElement();</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">					if (body != null) {</span>
<span class="nc" id="L191">						body = new JLogStructure(provider, &quot;,&quot;, body, toTerm(term));</span>
<span class="nc" id="L192">					} else {</span>
<span class="nc" id="L193">						body = toTerm(term);</span>
					}
				}
<span class="nc" id="L196">				return body;</span>
			}
<span class="nc" id="L198">			return new JLogTrue(provider);</span>

		default:
<span class="nc" id="L201">			throw new UnknownTermError(prologTerm);</span>
		}
	}

	public jTerm fromTerm(PrologTerm term) {
<span class="nc bnc" id="L206" title="All 14 branches missed.">		switch (term.getType()) {</span>
		case NIL_TYPE:
<span class="nc" id="L208">			return new jAtom(&quot;nil&quot;);</span>
		case CUT_TYPE:
<span class="nc" id="L210">			return new jAtom(&quot;!&quot;);</span>
		case FAIL_TYPE:
<span class="nc" id="L212">			return jFail.FAIL;</span>
		case TRUE_TYPE:
<span class="nc" id="L214">			return jTrue.TRUE;</span>
		case FALSE_TYPE:
<span class="nc" id="L216">			return new jAtom(&quot;false&quot;);</span>
		case ATOM_TYPE:
<span class="nc" id="L218">			String value = ((PrologAtom) term).getStringValue();</span>
<span class="nc" id="L219">			return new jAtom(value);</span>
		case FLOAT_TYPE:
<span class="nc" id="L221">			return new jFloat(((PrologFloat) term).getFloatValue());</span>
		case INTEGER_TYPE:
<span class="nc" id="L223">			return new jInteger(((PrologInteger) term).getIntegerValue());</span>
		case DOUBLE_TYPE:
<span class="nc" id="L225">			return new jDouble(((PrologDouble) term).getDoubleValue());</span>
		case LONG_TYPE:
<span class="nc" id="L227">			return new jInteger(((PrologLong) term).getIntegerValue());</span>
		case VARIABLE_TYPE:
<span class="nc" id="L229">			String name = ((PrologVariable) term).getName();</span>
<span class="nc" id="L230">			jTerm variable = sharedPrologVariables.get(name);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">			if (variable == null) {</span>
<span class="nc" id="L232">				variable = new jVariable(name);</span>
<span class="nc" id="L233">				sharedPrologVariables.put(name, variable);</span>
			}
<span class="nc" id="L235">			return variable;</span>
		case LIST_TYPE:
<span class="nc" id="L237">			PrologTerm[] arguments = ((PrologList) term).getArguments();</span>
<span class="nc" id="L238">			return adaptList(arguments);</span>
		case STRUCTURE_TYPE:
<span class="nc" id="L240">			String functor = term.getFunctor();</span>
<span class="nc" id="L241">			arguments = ((PrologStructure) term).getArguments();</span>
<span class="nc" id="L242">			return new jPredicate(functor, adaptCompound(arguments));</span>
		default:
<span class="nc" id="L244">			throw new UnknownTermError(term);</span>
		}
	}

	public jTerm[] fromTermArray(PrologTerm[] terms) {
<span class="nc" id="L249">		jTerm[] prologTerms = new jTerm[terms.length];</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">		for (int i = 0; i &lt; terms.length; i++) {</span>
<span class="nc" id="L251">			prologTerms[i] = fromTerm(terms[i]);</span>
		}
<span class="nc" id="L253">		return prologTerms;</span>
	}

	public jTerm fromTerm(PrologTerm head, PrologTerm[] body) {
<span class="nc" id="L257">		jTerm clauseHead = fromTerm(head);</span>
<span class="nc bnc" id="L258" title="All 4 branches missed.">		if (body != null &amp;&amp; body.length &gt; 0) {</span>
<span class="nc" id="L259">			jTerm clauseBody = fromTerm(body[body.length - 1]);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">			for (int i = body.length - 2; i &gt;= 0; --i) {</span>
<span class="nc" id="L261">				jCompoundTerm args = new jCompoundTerm(2);</span>
<span class="nc" id="L262">				args.addTerm(fromTerm(body[i]));</span>
<span class="nc" id="L263">				args.addTerm(clauseBody);</span>
<span class="nc" id="L264">				clauseBody = new jPredicate(&quot;,&quot;, args);</span>
			}
<span class="nc" id="L266">			jCompoundTerm args = new jCompoundTerm(2);</span>
<span class="nc" id="L267">			args.addTerm(clauseHead);</span>
<span class="nc" id="L268">			args.addTerm(clauseBody);</span>
<span class="nc" id="L269">			return new jPredicate(&quot;:-&quot;, args);</span>
		}
<span class="nc" id="L271">		return clauseHead;</span>
	}

	public PrologProvider createProvider() {
<span class="nc" id="L275">		return new JLog(this);</span>
	}

	@Override
	public int hashCode() {
<span class="nc" id="L280">		final int prime = 31;</span>
<span class="nc" id="L281">		int result = super.hashCode();</span>
<span class="nc" id="L282">		result = prime * result + emptyBody.hashCode();</span>
<span class="nc" id="L283">		result = prime * result + equivalence.hashCode();</span>
<span class="nc" id="L284">		return result;</span>
	}

	@Override
	public boolean equals(Object object) {
<span class="nc bnc" id="L289" title="All 2 branches missed.">		if (this == object)</span>
<span class="nc" id="L290">			return true;</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">		if (!super.equals(object))</span>
<span class="nc" id="L292">			return false;</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">		if (getClass() != object.getClass())</span>
<span class="nc" id="L294">			return false;</span>
<span class="nc" id="L295">		JLogConverter other = (JLogConverter) object;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">		if (!emptyBody.equals(other.emptyBody))</span>
<span class="nc" id="L297">			return false;</span>
<span class="nc" id="L298">		return equivalence.equals(other.equivalence);</span>
	}

	@Override
	public String toString() {
<span class="nc" id="L303">		return &quot;JLogConverter&quot;;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>